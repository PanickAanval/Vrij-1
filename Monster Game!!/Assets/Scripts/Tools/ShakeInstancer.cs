using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using Joeri.Tools.Utilities;

namespace Joeri.Tools
{
    public class ShakeInstancer
    {
        private float m_magnitude       = 0f;
        private float m_frequency       = 0f;
        private float m_smoothening     = 0f;  
        private float m_tickMark        = 0f;
        private float m_velocity        = 0f;

        private float m_tickTimer       = 0f;  
        private Vector3 m_startPosition = Vector3.zero;
        private Vector3 m_currentOffset = Vector3.zero;

        private const float m_epsilon   = 0.05f;

        public Vector3 startPosition    { get => m_startPosition; }
        public Vector3 currentOffset    { get => m_currentOffset; }
        public Vector3 currentPosition  { get => m_startPosition + m_currentOffset; }

        public float magnitude
        {
            get => m_magnitude;
            set
            {
                m_magnitude = value;
                ReInitialize();
            }
        }

        public float frequency
        {
            get => m_frequency;
            set
            {
                m_frequency = value;
                ReInitialize();
            }
        }

        public float smoothening
        {
            get => m_smoothening;
            set
            {
                m_smoothening = value;
                ReInitialize();
            }
        }

        public float mark { get => m_tickMark; }

        public ShakeInstancer(Vector3 startPosition, float magnitude, float frequency, float smoothening)
        {
            m_startPosition = startPosition;
            m_magnitude     = magnitude;
            m_frequency     = frequency;
            m_smoothening   = smoothening;
            m_tickMark      = 1f / frequency;

            m_tickTimer     = m_tickMark;
        }

        /// <summary>
        /// Iterates the shake instance forward.
        /// </summary>
        /// <returns>The position generated by the created offset.</returns>
        public Vector3 GetPosition(float deltaTime)
        {
            return m_startPosition + GetOffset(deltaTime);
        }

        /// <summary>
        /// Iterates the shake instance forward.
        /// </summary>
        /// <returns>The offset generated.</returns>
        public Vector3 GetOffset(float deltaTime)
        {
            //  Rest if the magnitude is lower than epsilon.
            if (m_magnitude <= m_epsilon)
            {
                m_currentOffset = Vector3.zero;
                return Vector3.zero;
            }

            //  Wait until the timer has passed the mark for further action.
            m_tickTimer += deltaTime;
            m_magnitude = Mathf.SmoothDamp(m_magnitude, 0f, ref m_velocity, m_smoothening, Mathf.Infinity, deltaTime);
            //m_magnitude = Mathf.Lerp(m_magnitude, 0f, deltaTime / smoothening);
            if (m_tickTimer < m_tickMark) return m_currentOffset;
            m_tickTimer = 0f;

            //  Create new offset, and lower the magnitude.
            m_currentOffset = Vectors.RandomSpherePoint(m_magnitude);

            Debug.Log(m_magnitude);

            //  Return.
            return m_currentOffset;
        }

        public void ReInitialize()
        {
            m_velocity      = 0f;
            m_tickMark      = 1f / m_frequency;
            m_tickTimer     = m_tickMark;
            m_currentOffset = Vector3.zero;
        }
    }
}
